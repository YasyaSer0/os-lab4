# МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ  
## КИЇВСЬКИЙ ФАХОВИЙ КОЛЕДЖ ЗВ’ЯЗКУ  

---

# ЗВІТ  
## про виконання лабораторної роботи №4
### з дисципліни «Операційні системи»

---

**Тема:**  
Команди Linux для управління процесами

---

**Виконала:**  
студентка групи **БІКС-33**  
**Сербіна Ярослава Вячеславівна**

---

**Перевірила:**  
**Сушанова Вікторія Сергіївна**

---

**Київ - 2026**

---

# Лабораторна робота №4
## Операційні системи

---

## Тема
Команди Linux для управління процесами

---

## Мета роботи
1. Отримання практичних навиків роботи з командною оболонкою Bash.
2. Знайомство з базовими командами для управління процесами.

---

## Матеріальне забезпечення занять:
1. ЕОМ типу IBM PC.  
2. ОС сімейства Windows та віртуальна машина VirtualBox (Oracle).  
3. ОС GNU/Linux (будь-який дистрибутив).  
4. Сайт мережевої академії Cisco netacad.com та його онлайн курси по Linux.

---

## Завдання для попередньої підготовки
### Glossary of Basic English Terms 

**Process** - A program that is currently running on the system.

**Process ID (PID)** - A unique identification number assigned to each running process.

**ps Command** - A command used to display information about processes running on the system.

**top Command** - A real-time monitoring tool that displays dynamic information about running processes.

**Unix-style Parameters** - Command options preceded by a single dash (-).

**GNU Long Parameters** - Command options preceded by a double dash (--).

**Full Format Listing (-f)** - An option of the ps command that displays extended process information.

**Long Listing (-l)** - An option of the ps command that displays detailed process information with additional columns.

**All Processes (-e)** - An option that shows all processes running on the system.

**TTY** - The terminal device from which a process was started.

**CPU Utilization (%CPU)** - The percentage of processor time used by a process.

**Memory Utilization (%MEM)** - The percentage of physical memory used by a process.

**Virtual Memory (VIRT)** - The total amount of virtual memory used by a process.

**Resident Memory (RES)** - The amount of physical memory currently used by a process.

**Process State** - The current status of a process (running, sleeping, stopped, or zombie).

**Signal** - A predefined message sent to a process to control its behavior.

**TERM Signal (15)** - A signal that requests a process to terminate if possible.

**KILL Signal (9)** - A signal that forcefully and unconditionally terminates a process.

**STOP Signal (17)** - A signal that stops a process without terminating it.

**CONT Signal (19)** - A signal that resumes a stopped process.

**kill Command** - A command used to send signals to processes using their PID.

**killall Command** - A command used to terminate processes by their name instead of PID.

**Real-Time Monitoring** - The ability to observe system processes continuously as they change.


## Відповіді на теоретичні питання

### Які команди для моніторингу стану процесів ви знаєте? Як переглянути їх можливі параметри?

Для моніторингу процесів у Linux використовуються команди **ps** та **top**.

Команда **ps** дозволяє переглянути інформацію про процеси, які виконуються в системі (PID, користувач, час роботи, стан тощо).

Команда **top** використовується для моніторингу процесів у реальному часі. Вона показує завантаження процесора, використання пам’яті та список активних процесів.

Переглянути можливі параметри команд можна за допомогою:
- `man ps`
- `man top`
- або `ps --help`

### Чи може команда ps у реальному часі відслідковувати стан процесів?

Ні, команда **ps** не відслідковує процеси у реальному часі.  
Вона показує стан процесів лише на конкретний момент виконання команди.

Для моніторингу процесів у реальному часі використовується команда **top**.

### За якими параметрами можливе сортування процесів в команді top? Як переключатись між ними?

За замовчуванням команда **top** сортує процеси за параметром **%CPU** (відсоток використання процесора).

Також можна змінити сортування за іншими полями, наприклад:
- %CPU
- %MEM
- PID
- TIME

Щоб переключатися між параметрами сортування, потрібно під час роботи `top` натиснути клавішу **f** та вибрати потрібне поле.

Вийти з команди `top` можна натиснувши **q**.

### Які команди для завершення роботи процесів ви знаєте?

Для завершення роботи процесів у Linux використовуються команди **kill** та **killall**.

Команда `kill` використовується для надсилання сигналу процесу за його PID (Process ID). 
За замовчуванням вона надсилає сигнал **TERM (15)**, який коректно завершує процес, якщо це можливо.

Приклад:
`kill 1234`

Якщо процес не завершується, можна використати примусовий сигнал **KILL (9)**:
`kill -9 1234`

Команда `killall` дозволяє завершувати процеси за їх назвою, а не за PID. 
Це зручно, якщо потрібно завершити одразу декілька процесів з однаковою назвою.

Приклад:
`killall sleep`

Таким чином, основними командами для завершення процесів є `kill` та `killall`, які працюють через систему сигналів Linux.

---

## Хід роботи

**1. Запуск системи**

Я запустила віртуальну машину **VM2_Linux_CLI** у VirtualBox та виконала вхід у систему.  
Після авторизації відкрився командний рядок (CLI), у якому виконувалась лабораторна робота.

<img width="967" height="926" alt="image" src="https://github.com/user-attachments/assets/b1e39eee-7477-44bd-85e9-7fadbd27ee17" />

Скрін 1 - Запущена віртуальна машина та вхід у систему

**2. Робота з директорією /proc**

Команди:
```bash
ls /proc | head
cat /proc/cpuinfo | head
cat /proc/meminfo | head
```
Пояснення:

Директорія /proc знаходиться у кореневому каталозі /.
Вона є віртуальною файловою системою, яка створюється ядром під час роботи системи.

У ній міститься:
- інформація про всі запущені процеси (каталоги з PID),
- дані про процесор,
- інформація про оперативну пам’ять,
- параметри ядра.

Файли у /proc не зберігаються фізично на диску - вони формуються динамічно.

<img width="549" height="422" alt="image" src="https://github.com/user-attachments/assets/dd7cfdd5-8e54-439f-bb70-86681e3ccbce" />

<img width="730" height="245" alt="image" src="https://github.com/user-attachments/assets/b6029dd3-e3e4-4579-b253-4c5b636c9c5f" />

<img width="751" height="243" alt="image" src="https://github.com/user-attachments/assets/6f6830bd-32df-473b-be05-ec83ea788748" />

Скрін 2 - Вміст директорії /proc та системна інформація

**3. Інформація про поточні сеанси користувачів**

Команда:
```bash
w
```
або
```bash
who
```

Пояснення:
Команда w показує:
- активних користувачів,
- час входу в систему,
- з якого терміналу виконано вхід,
- навантаження системи.

Команда who виводить список користувачів, які наразі працюють у системі.

<img width="814" height="157" alt="image" src="https://github.com/user-attachments/assets/395ea868-8c43-49cc-aeb9-a6346fb76ce1" />

Скрін 3 - Інформація про активні сеанси користувачів

**4. Комбінації клавіш у терміналі**

4.1 Використання Ctrl + C

Команда для демонстрації:
```bash
sleep 100
```
Після запуску команди було натиснуто комбінацію клавіш:
```bash
Ctrl + C
```
Пояснення:

Комбінація Ctrl + C використовується для примусового завершення виконання команди.
Вона надсилає сигнал SIGINT (Interrupt) процесу.

У результаті:
- виконання команди зупиняється,
- процес завершується,
- з’являється символ ^C,
- командний рядок повертається.
  
<img width="459" height="86" alt="image" src="https://github.com/user-attachments/assets/e3140758-39ce-498a-b75e-d0b5cafc6cb3" />

Скрін 4 - Демонстрація Ctrl + C
  
4.2 Використання Ctrl + Z

Команда для демонстрації:
```bash
sleep 200
```
Після запуску було натиснуто:
```bash
Ctrl + Z
```
Потім виконано:
```bash
jobs
```
Пояснення:

Комбінація Ctrl + Z призупиняє виконання процесу.
Процес не завершується, а переходить у стан Stopped.

Команда jobs дозволяє переглянути список призупинених або фонових задач.

У результаті видно:
```bash
[1]+ Stopped sleep 200
```

 <img width="498" height="167" alt="image" src="https://github.com/user-attachments/assets/90c5aa49-8cbf-4a34-bcd7-f1704a4b83fc" />

 Скрін 5 - Демонстрація Ctrl + Z та команда jobs

4.3 Використання Ctrl + D
Пояснення:

Комбінація Ctrl + D використовується для:
- завершення сеансу терміналу,
- виходу з shell,
- передачі сигналу EOF (End Of File).

Якщо натиснути Ctrl + D у терміналі:
- відбудеться вихід із поточного сеансу,
- або завершиться введення даних.
  
**5. Фонові та звичайні процеси**

5.1 Звичайний процес (Foreground)

Команда для демонстрації:
```bash
sleep 60
```
Пояснення:

Звичайний процес (foreground) виконується на передньому плані та повністю займає термінал до завершення своєї роботи.

Поки процес працює:
- неможливо вводити інші команди,
- термінал заблокований,
- користувач змушений чекати завершення або примусово завершити процес (Ctrl + C).

Такий режим використовується для:
- короткотривалих команд,
- інтерактивних програм,
- команд, з якими потрібно працювати безпосередньо.

<img width="477" height="56" alt="image" src="https://github.com/user-attachments/assets/3a761d83-8aea-43da-b76a-95b5dc836cfb" />

Скрін 5 — Запуск sleep 60 у режимі foreground

5.2 Фоновий процес (Background)

Команда для демонстрації:
```bash
sleep 60 &
```
Після запуску було виконано:
```bash
jobs
```
Пояснення:

Фоновий процес (background) виконується у фоновому режимі та не блокує термінал.

Після запуску:
- з’являється номер задачі та PID,
- можна одразу вводити інші команди,
- процес продовжує виконання паралельно.

Команда jobs дозволяє перевірити статус фонового процесу (Running або Stopped).

Фонові процеси використовуються для:
- довготривалих задач,
- обчислень,
- завантажень,
- серверних процесів,
- роботи служб системи.

<img width="594" height="212" alt="image" src="https://github.com/user-attachments/assets/12f20b7f-b14e-443d-a311-dc7576d61e12" />

Скрін 6 — Запуск sleep 60 & та виконання іншої команди (наприклад, ls)

5.3 Основна відмінність
| Foreground                       | Background                    |
| -------------------------------- | ----------------------------- |
| Блокує термінал                  | Не блокує термінал            |
| Не дозволяє вводити інші команди | Дозволяє працювати паралельно |
| Виконується на передньому плані  | Виконується у фоновому режимі |

**6. Опис команд jobs, bg, fg**

6.1 Команда jobs

Команда:
```bash
jobs
```
Хід виконання:

Було запущено процес:
```bash
sleep 200
```
Після цього процес призупинено за допомогою комбінації клавіш:
```bash
Ctrl + Z
```
У результаті з’явилось повідомлення:
```bash
[1]+ Stopped sleep 200
```
Далі було виконано команду:
```bash
jobs
```
Пояснення:

Команда jobs використовується для перегляду списку задач (процесів), які:
- призупинені (Stopped),
- або виконуються у фоновому режимі (Running),
- і були запущені саме у поточному терміналі.

У виведенні відображається:
- номер задачі - [1],
- статус процесу - Stopped,
- назва виконуваної команди - sleep 200.

У даному випадку видно, що процес sleep 200 знаходиться у стані Stopped, тобто він призупинений і очікує подальших дій (відновлення через bg або fg).

<img width="729" height="168" alt="image" src="https://github.com/user-attachments/assets/3569e4ab-f3ad-4171-a6a5-861ae449c76e" />

Скрін 7 - Демонстрація роботи команди jobs (призупинений процес sleep 200)

6.2 Команда bg

Команда:

```bash
bg %1
```
Хід виконання:

Після того як процес sleep 200 було призупинено (Ctrl + Z) і перевірено через jobs, було виконано команду:
```bash
bg %1
```
У результаті з’явилось повідомлення:
```bash
[1]+ sleep 200 &
```
Далі було виконано перевірку:
```bash
jobs
```
Результат:
```bash
[1]+ Running sleep 200 &
```

Пояснення:

Команда bg (background) використовується для відновлення призупиненого процесу та переведення його у фоновий режим.
- %1 означає номер задачі (job number), який відображається у команді jobs.
- Символ & означає, що процес виконується у фоновому режимі.
- Статус змінюється з Stopped на Running.

Після виконання bg %1 процес продовжує роботу у фоновому режимі і не блокує термінал, тобто можна вводити інші команди.

<img width="693" height="140" alt="image" src="https://github.com/user-attachments/assets/0d28f6d7-473d-4c07-aa8d-42ba7a5cb224" />

Скрін 8 - Виконання команди bg %1 та перевірка через jobs (статус Running)

6.3 Команда fg

Команда:

```bash
fg %1
```
Хід виконання:

Після того як процес sleep 200 працював у фоновому режимі (background), було виконано команду:
```bash
fg %1
```
У результаті процес повернувся на передній план:
```bash
sleep 200
```
Далі процес було знову призупинено за допомогою комбінації клавіш:
```bash
Ctrl + Z
```
У результаті з’явилось повідомлення:
```bash
[1]+ Stopped sleep 200
```
Після цього було виконано перевірку:
```bash
jobs
```
Результат показав:
```bash
[1]+ Stopped sleep 200
```
Пояснення:

Команда fg (foreground) використовується для повернення процесу з фонового режиму на передній план.
- %1 означає номер задачі (job number), який можна побачити через команду jobs.
- Після виконання fg %1 процес починає виконуватись у режимі foreground.
- У цьому режимі процес займає термінал і не дозволяє вводити інші команди.
- За потреби процес можна знову призупинити за допомогою Ctrl + Z.

У даному випадку видно, що процес sleep 200 було повернуто на передній план, а потім знову призупинено.

<img width="673" height="229" alt="image" src="https://github.com/user-attachments/assets/0b3269a0-4548-4067-be2d-1c0101b90c10" />

Скрін 9 - Виконання команди fg %1 та повторне призупинення процесу

**7. Перегляд фонових процесів**

Для перегляду задач, запущених у фоновому режимі, використовується команда:
```bash
jobs
```
Для демонстрації було запущено процес:
```bash
sleep 120 &
```
Символ & означає запуск процесу у фоновому режимі.

Команда jobs показала:
- номер задачі - [1],
- статус - Running,
- назву процесу - sleep 120,
- символ &, що підтверджує фоновий режим.

<img width="503" height="121" alt="image" src="https://github.com/user-attachments/assets/3a780fb7-ab75-4f66-a869-ee5efb041c81" />

Скрін 10 - Перегляд фонового процесу за допомогою команди jobs.

**8. Призупинення, відновлення та перезапуск фонового процесу**

8.1 Запуск фонового процесу

Для демонстрації було запущено процес у фоновому режимі:
```bash
sleep 200 &
```
У результаті з’явився номер задачі та PID процесу:
```bash
[1] 4044
```
Після цього було виконано перевірку:
```bash
jobs
```
Результат:
```bash
[1]+ Running sleep 200 &
```
Пояснення:
- Символ & означає запуск процесу у фоновому режимі (background).
- Команда jobs підтвердила, що процес виконується зі статусом Running.

<img width="544" height="106" alt="image" src="https://github.com/user-attachments/assets/530a4ffa-2580-4432-8291-5abf22530db1" />

Скрін 11 - Запуск фонового процесу та перевірка через jobs

8.2 Призупинення фонового процесу

Щоб призупинити фоновий процес, його спочатку було повернуто у foreground:
```bash
fg %1
```
Процес почав виконуватись на передньому плані:
```bash
sleep 200
```
Після цього було натиснуто комбінацію клавіш:
```bash
Ctrl + Z
```
У результаті з’явилось повідомлення:
```bash
[1]+ Stopped sleep 200
```
Перевірка:
```bash
jobs
```
Показала:
```bash
[1]+ Stopped sleep 200
```
Пояснення:
- Команда fg %1 повертає процес на передній план.
- Комбінація Ctrl + Z призупиняє процес і переводить його у стан Stopped.

<img width="523" height="142" alt="image" src="https://github.com/user-attachments/assets/6f0bbad6-5a94-45cd-a73d-0dc5e7b8e3ae" />

Скрін 12 - Призупинення процесу (Stopped)

8.3 Завершення процесу

Для завершення процесу було використано команду:
```bash
kill %1
```
Після цього виконано перевірку:
```bash
jobs
```
Результат:
```bash
[1]+ Terminated sleep 200
```
Пояснення:
- Команда kill %1 надсилає сигнал завершення задачі №1.
- Статус Terminated означає, що процес успішно завершений.

<img width="482" height="69" alt="image" src="https://github.com/user-attachments/assets/afc1ddb1-6b13-497a-a84d-a374c8acc091" />

Скрін 13 — Завершення процесу через kill

8.4 Перезапуск процесу

Після завершення процес було запущено повторно:
```bash
sleep 200 &
```
З’явився новий PID:
```bash
[1] 4046
```
Пояснення:
- Процес було перезапущено у фоновому режимі.
- Новий PID означає, що створено новий процес.
  
<img width="473" height="89" alt="image" src="https://github.com/user-attachments/assets/b19e3608-32e1-48fe-8ffb-9301c2cd89ae" />

Скрін 14 — Повторний запуск фонового процесу

 ### Практична частина
**9. Аналіз роботи системи за допомогою команди top**

9.1 Запуск команди

Для моніторингу процесів у реальному часі було виконано команду:
```bash
top
```
<img width="841" height="585" alt="image" src="https://github.com/user-attachments/assets/babad745-9a21-4b0f-8c65-eaebfd4fb61c" />

Скрін 15 — Робота команди top

9.2 Аналіз отриманої інформації

Загальна інформація про систему

У верхній частині вікна відображається:
- Час роботи системи (uptime): 2:29
- Кількість користувачів: 1 user
- Load average: 0.01, 0.01, 0.00

Низьке значення load average означає, що система практично не навантажена.

Також відображається кількість процесів:
- 208 total
- 1 running
- 207 sleeping
- 0 zombie

Це означає, що більшість процесів знаходяться в режимі очікування.

Використання процесора (CPU)
```bash
%Cpu(s): 0.3 us, 0.3 sy, 99.3 id
```
- 0.3% - використовується користувацькими процесами (us)
- 0.3% - використовується системними процесами (sy)
- 99.3% - процесор простоює (idle)

Це свідчить про стабільну роботу системи без перевантаження.

Використання оперативної пам’яті
```bash
MiB Mem : 1967.7 total, 496.0 free, 866.1 used, 775.0 buff/cache
MiB Swap: 2048.0 total, 2048.0 free, 0.0 used
```
- Загальна оперативна пам’ять: ~1967 MB
- Використовується: 866 MB
- Вільно: 496 MB
- Частина використовується під кеш (buffer/cache)
- Swap-пам’ять не використовується

Це свідчить про нормальний стан системної пам’яті.

9.3 Найбільш активні процеси

У нижній частині відображається список процесів, відсортований за параметром %CPU.

Найбільш активними процесами є:
- Xorg - графічний сервер (0.7% CPU, 5.1% пам’яті)
- VBoxClient - процес VirtualBox
- gnome-terminal або gnome-shell
- сам процес top

Жоден процес не створює значного навантаження, що підтверджує стабільність роботи системи.

9.4 Висновок

Команда top дозволяє в режимі реального часу:
- контролювати завантаження процесора,
- аналізувати використання пам’яті,
- визначати найбільш активні процеси,
- оцінювати загальний стан системи.

У даному випадку система працює стабільно, без перевантаження CPU та пам’яті.

**10. Призупинення виконання команди top**

10.1 Призупинення виконання команди

Після запуску команди top було виконано її призупинення за допомогою комбінації клавіш:
```bash
Ctrl + Z
```
Після натискання у терміналі з’явилось повідомлення:
```bash
[1]+ Stopped top
```
Це означає, що процес top було не завершено, а переведено у стан призупинення (Stopped).

<img width="870" height="531" alt="image" src="https://github.com/user-attachments/assets/e2b876cb-5b90-40ae-8f19-34ad542e02da" />

Скрін 16 - Призупинення команди top (Ctrl + Z)

10.2 Перевірка статусу призупиненого процесу

Для перевірки стану процесу було використано команду:
```bash
jobs
```
Результат виконання:
```bash
[1]+ Stopped top
```
Команда jobs показує список поточних задач оболонки (shell), зокрема:
- призупинені процеси,
- фонові процеси,
- їхній номер та статус.

<img width="396" height="88" alt="image" src="https://github.com/user-attachments/assets/a7f738ed-faa3-4217-b477-5eeab7bbddd1" />

Скрін 17 - Перевірка статусу процесу командою jobs

10.3 Пояснення виконаних дій

Комбінація клавіш Ctrl + Z:
- надсилає процесу сигнал призупинення (SIGTSTP),
- переводить його у стан Stopped,
- повертає користувачу доступ до командного рядка.

Процес залишається у пам’яті та може бути:
- відновлений у режимі foreground (команда fg),
- переведений у background (команда bg),
- або завершений (команда kill).

**11. Виведення інформації про процеси за допомогою команди ps**

11.1 Виконання базової команди ps

Для перегляду активних процесів у поточному термінальному сеансі було виконано команду:
```bah
ps
```
Результат виконання команди відображає список процесів, що запущені в даному терміналі.

<img width="400" height="150" alt="image" src="https://github.com/user-attachments/assets/61a5fac8-4907-4f1b-a03f-993001c99d28" />

Скрін 18 - Результат виконання команди ps

Пояснення отриманого результату

У виведенні команди ps відображаються такі стовпці:
- PID (Process ID) - унікальний ідентифікатор процесу;
- TTY - термінал, з якого запущено процес;
- TIME - загальний час використання процесора;
- CMD - назва виконуваної команди.

На скріні видно наступні процеси:
- bash - оболонка командного рядка;
- top - команда моніторингу процесів;
- ps - поточна виконувана команда.

Команда ps показує стан процесів на момент її виконання.

На відміну від top, вона не оновлює інформацію в реальному часі.

**12. Використання команди ps з різними параметрами**

У даному розділі наведено 5 прикладів використання команди ps з різними параметрами для аналізу процесів у системі Linux.

12.1 Виведення всіх процесів системи

Команда:
```bash
ps -e
```

<img width="768" height="554" alt="image" src="https://github.com/user-attachments/assets/aae8659b-4899-405f-88e5-d7dbf0e59e19" />

Скрін 19 - Виконання команди ps -e

Пояснення:

Параметр -e (every) дозволяє вивести всі процеси, що виконуються в системі, включаючи системні процеси.

На скріні видно системні процеси, такі як:
- systemd
- kthreadd
- kworker
- rcu_tasks_kthread тощо.

Це дозволяє отримати повний список активних процесів у системі.

12.2 Виведення всіх процесів у повному форматі

Команда:
```bash
ps -ef
```

<img width="801" height="510" alt="image" src="https://github.com/user-attachments/assets/6ffbc9fc-cdb3-4486-ada7-3127e5958186" />

Скрін 20 - Виконання команди ps -ef

Пояснення:
- -e - показує всі процеси;
- -f - повний формат (full format).

Додатково відображаються:
- UID - користувач;
- PID - ідентифікатор процесу;
- PPID - батьківський процес;
- STIME - час запуску;
- CMD - команда.

Цей варіант є більш інформативним для аналізу процесів.

12.3 Виведення процесів конкретного користувача

Команда:
```bash
ps -u $USER
```

<img width="694" height="502" alt="image" src="https://github.com/user-attachments/assets/4d2cf1ed-a92d-4df6-9421-1e1bdaf19457" />

Скрін 21 - Виконання команди ps -u $USER

Пояснення:

Параметр -u дозволяє вивести процеси конкретного користувача.

Змінна $USER підставляє ім’я поточного користувача

 На скріні видно процеси, пов’язані з:
- Xorg
- VBoxClient
- xfce4-session
- ibus-daemon тощо.

Це дозволяє аналізувати активність окремого користувача.

12.4 Виведення процесів у вигляді дерева

Команда:
```bah
ps -ejH
```

<img width="828" height="553" alt="image" src="https://github.com/user-attachments/assets/ccf1a69b-a6d8-4e72-81b4-38a026359e93" />

Скрін 22 - Виконання команди ps -ejH

Пояснення:
- -e - всі процеси;
- -j - формат job;
- -H - відображення ієрархії процесів (дерево).

Команда дозволяє побачити взаємозв’язок між процесами — який процес є батьківським, а який дочірнім.

Це дуже корисно для аналізу структури системи.

12.5 Сортування процесів за використанням пам’яті

Команда:
```bash
ps aux --sort=-%mem
```

<img width="821" height="517" alt="image" src="https://github.com/user-attachments/assets/6024dd9f-643f-44b0-9a05-613d8296368a" />

Скрін 23 - Виконання команди ps aux --sort=-%mem

Пояснення:
- a - процеси всіх користувачів;
- u - розширена інформація;
- x - процеси без прив’язки до терміналу;

--sort=-%mem - сортування за спаданням використання оперативної пам’яті.

На скріні видно, що першими відображаються процеси, які використовують найбільше пам’яті (наприклад, Xorg, xfwm4, xfce4-session).

Це дозволяє визначити найбільш ресурсоємні процеси.

**13. Перевірка наявності запущених фонових процесів**

13.1 Перевірка фонових задач

Для перевірки наявності фонових або призупинених процесів було виконано команду:
```bash
jobs
```
<img width="568" height="204" alt="image" src="https://github.com/user-attachments/assets/e53a5bb9-b26e-4e01-897a-e99462fa09e1" />

Скрін 24 - Результат виконання команди jobs

Пояснення результату

У результаті виконання команди відображено:
```bash
[1]+ Stopped top
```
Це означає, що:
- у системі є призупинений процес;
- номер задачі - 1;
- процес знаходиться у стані Stopped;
- назва процесу - top.

Процес top було раніше призупинено за допомогою комбінації клавіш Ctrl + Z, тому він відображається як призупинений.

Команда jobs показує тільки задачі поточної оболонки (shell), тобто процеси, які були запущені або призупинені саме у цьому терміналі.

**14. Відновлення призупиненого процесу у foreground та background**

14.1 Відновлення процесу у режимі foreground

Для відновлення призупиненого процесу top було виконано команду:
```bash
fg %1
```
Після виконання цієї команди процес top знову почав працювати у режимі переднього плану (foreground) та зайняв екран терміналу.

<img width="837" height="567" alt="image" src="https://github.com/user-attachments/assets/f34bd4e5-c985-4eaf-a975-605eed3a4f9d" />

Скрін 24 - Відновлення процесу командою fg %1

14.2 Повторне призупинення процесу

Для повторного призупинення процесу було використано комбінацію клавіш:
```bash
Ctrl + Z
```
Після цього у терміналі з’явилось повідомлення:
```bash
[1]+ Stopped top
```
Це означає, що процес знову переведено у стан призупинення.

<img width="489" height="522" alt="image" src="https://github.com/user-attachments/assets/ea0871ca-b9b0-482f-946a-a0f96a7cbc64" />

Скрін 25 - Повторне призупинення процесу top

14.3 Відновлення процесу у режимі background

Для запуску процесу у фоновому режимі було виконано команду:
```bash
bg %1
```
Однак після виконання команди та перевірки через:
```bash
jobs
```
було встановлено, що процес top знову переходить у стан:
```bash
[1]+ Stopped top
```
Це пов’язано з тим, що команда top є інтерактивною програмою та потребує активного терміналу для відображення інформації. При переведенні у background вона автоматично призупиняється.

<img width="413" height="155" alt="image" src="https://github.com/user-attachments/assets/c098a8a5-90d2-4d1e-be54-61924b595c4b" />

Скрін 26 - Спроба переведення top у background та перевірка через jobs

**15. Завершення роботи фонового процесу**

15.1 Запуск фонового процесу

Для демонстрації завершення фонового процесу було виконано команду:
```bash
sleep 200 &
```
Символ & використовується для запуску процесу у фоновому режимі (background).

Після виконання команди система відобразила:
```bash
[1] 4571
```
де:
- [1] - номер задачі (job number);
- 4571 - ідентифікатор процесу (PID).
  
<img width="495" height="211" alt="image" src="https://github.com/user-attachments/assets/16a6fe5e-cce5-43e0-8c9d-59de03e2cff2" />

Скрін 27 - Запуск, перевірка та завершення фонового процесу

15.2 Перевірка активного фонового процесу

Для перевірки наявності запущених фонових процесів було виконано команду:
```bash
jobs
```
Результат:
```bash
[1]+ Running sleep 200 &
```
Це означає, що процес sleep 200 виконується у фоновому режимі.

15.3 Завершення фонового процесу

Для завершення процесу було використано команду:
```bash
kill %1
```
де %1 - номер задачі, отриманий через jobs.

Після виконання команди було знову виконано:
```bash
jobs
```
Результат:
```bash
[1]+ Terminated sleep 200
```
Це означає, що фоновий процес успішно завершено.

Пояснення виконаних дій
- sleep 200 & - запускає процес у фоновому режимі;
- jobs - показує список фонових задач поточної оболонки;
- kill %1 - завершує процес за номером задачі;
- після завершення процес більше не виконується.

## Контрольні запитання

**1. Яке призначення директорії /proc в системах Linux? Яку інформацію вона зберігає?**

Директорія /proc - це спеціальна віртуальна файлова система в Linux, яка містить інформацію про поточний стан ядра та запущених процесів.

Вона не зберігає звичайні файли на диску, а формує інформацію динамічно під час роботи системи.

Директорія знаходиться в кореневій файловій системі:
```bash
/proc
```

---

Перегляд вмісту директорії /proc

Для перегляду вмісту було виконано команду:
```bash
ls /proc
```

<img width="803" height="534" alt="image" src="https://github.com/user-attachments/assets/016040f8-417f-4a0b-958b-59d4dc50d40c" />

Скрін 1 

Пояснення:

У виведенні видно:
- папки з номерами (наприклад: 1, 207, 2235 тощо) - це ID запущених процесів (PID);
- системні файли:
- cpuinfo
- meminfo
- mounts
- modules
- uptime
- sys
- net

Це підтверджує, що /proc містить інформацію як про систему, так і про окремі процеси.

---

Перегляд інформації про процесор

Було виконано:
```bash
cat /proc/cpuinfo | head
```

<img width="727" height="259" alt="image" src="https://github.com/user-attachments/assets/75c0e27c-7d7c-4139-8f17-95b52270a0c1" />

Скрін 2

Пояснення:

У файлі /proc/cpuinfo міститься:
- модель процесора
- виробник
- частота
- технічні характеристики

У моєму випадку видно процесор Intel 11th Gen Core i7.

---

Перегляд інформації про оперативну пам’ять

Було виконано:
```bash
cat /proc/meminfo | head
```

<img width="625" height="265" alt="image" src="https://github.com/user-attachments/assets/3e3ab797-99ae-4b74-8f42-a823eb9db044" />

Скрін 3 

Пояснення:

Файл /proc/meminfo містить:
- загальний обсяг пам’яті (MemTotal)
- вільну пам’ять (MemFree)
- доступну пам’ять (MemAvailable)
- буфери та кеш

Це дозволяє аналізувати використання оперативної пам’яті в системі.

---

Перегляд інформації про конкретний процес (PID 1)

Було виконано:
```bash
ls /proc/1
```

<img width="780" height="446" alt="image" src="https://github.com/user-attachments/assets/6c94585b-5a22-4bba-b8af-283876d69d5f" />

Скрін 4 

Пояснення:

Папка /proc/1 відповідає процесу з PID 1 (systemd).

У ній містяться:
- cmdline - команда запуску процесу
- status - стан процесу
- maps - використання пам’яті
- fd - відкриті файли
- cwd - робоча директорія

Повідомлення “Permission denied” означає, що деякі файли доступні лише для root-користувача.

**2. Як серед будь-яких трьох процесів динамічно визначати, який з них використовує найбільше пам’яті? Який відсоток пам’яті він споживає?**

Для динамічного визначення використання пам’яті можна застосувати команду:
```bash
top
```
У таблиці відображається стовпець %MEM, який показує відсоток використання оперативної пам’яті кожним процесом.

Також можна використати:
```bash
ps aux --sort=-%mem
```
Ця команда сортує процеси за спаданням використання пам’яті.

Процес, що знаходиться першим у списку, використовує найбільший обсяг пам’яті.

Відсоток споживання відображається у колонці %MEM.

**3. Як отримати ієрархію батьківських процесів? Опишіть її структуру.**

Ієрархію процесів можна отримати командою:
```bash
ps -ejH
```
або
```bash
pstree
```
Структура процесів в Linux є ієрархічною:
- на вершині знаходиться процес systemd (PID 1);
- від нього створюються дочірні процеси;
- кожен процес має батьківський процес (PPID).

Структура виглядає як дерево, де:
- верхній процес - корінь,
- нижчі процеси - дочірні.

**4. Чим відрізняється команда top від ps?**

Команда ps:
- показує стан процесів лише на момент виконання;
- не оновлюється автоматично;
- підходить для статичного аналізу.

Команда top:
- працює у реальному часі;
- постійно оновлює інформацію;
- дозволяє сортувати процеси;
- показує навантаження CPU та пам’яті.

Тобто ps - статичний знімок, а top - динамічний моніторинг.

**5. Які додаткові можливості має htop порівняно з top?**

htop - це покращена версія top.

Він має:
- кольоровий інтерфейс;
- зручну навігацію стрілками;
- можливість прокрутки списку;
- можливість завершення процесів клавішами;
- відображення процесів у вигляді дерева;
- більш зручний інтерфейс.

htop є більш сучасним і зручним для користувача.

**6. Опишіть компоненти вашої мобільної ОС для здійснення моніторингу процесів (iOS)**

У мобільній операційній системі iOS (iPhone) моніторинг процесів реалізований на системному рівні та частково доступний користувачу.

Основні компоненти:
- App Switcher (меню відкритих програм) - дозволяє переглядати активні та нещодавно використані додатки.
- Налаштування → Акумулятор - показує, які додатки використовують найбільше ресурсів та енергії.
- Налаштування → Основні → Сховище iPhone - відображає використання пам’яті додатками.
- Системний менеджер пам’яті iOS - автоматично керує фоновими процесами та закриває їх при нестачі ресурсів.

На відміну від Linux або Android, користувач не має прямого доступу до списку процесів через термінал.

**7. Чи підтримує iOS термінальне керування процесами?**

Стандартна iOS не підтримує термінальне керування процесами.

Користувач:
- не має доступу до командного рядка;
- не може використовувати команди типу ps, top, kill;
- не має доступу до системних процесів.

Усі процеси керуються системою автоматично.

Повний доступ можливий лише після jailbreak, але це не рекомендовано, оскільки порушує безпеку системи.

**8. Чи можливо встановити сторонні засоби для моніторингу процесів на iPhone?**

Так, частково можливо.

Без jailbreak можна встановити:
- додатки для моніторингу використання пам’яті та батареї;
- системні утиліти з App Store (наприклад, CPU monitor);
- використовувати Xcode (через Mac) для перегляду процесів при розробці.

З jailbreak можливо встановлювати розширені інструменти (через Cydia), але це:
- порушує гарантію;
- знижує безпеку пристрою.

## Conclusion 

During this laboratory work, I studied the principles of process management in the Linux operating system using the CLI mode. I learned how to start, suspend, resume, and terminate processes using commands such as ps, top, jobs, bg, fg, and kill.

I explored the /proc directory and understood its purpose and the type of system information it provides. I also learned how to monitor system activity, analyze CPU and memory usage, and identify the most active processes in real time.

Special attention was given to working with foreground and background processes, as well as using keyboard shortcuts like Ctrl + C, Ctrl + Z, and Ctrl + D.

As a result of this laboratory work, I gained practical skills in monitoring and managing processes in Linux, which are essential for system administration and understanding operating system functionality.
